# Pyshell
My own handmake Python shell for linux

本程序利用python语言进行模拟shell编程，通过自定义某些函数实现一些特定功能和个性化功能，同时保留了linuxshell里的原有功能．流程思路如下：
    首先介绍下整个脚步的目录结构，项目主要分为４个模块，主程序运行模块pshell.py,主要是主进程的循环和相关逻辑控制．自定义shell功能的init_commnad模块，这里是代码主要部分，存放主要的功能函数供主程序调用．re_compile 模块，通过通过编译的正则表达式实现一些自定义命令的匹配和关键参数提取．help模块，提供给用户的帮助文档，即命令的使用方法和脚本的描述文档．
    
基本流程：
    主循环（主进程）接收命令－－＞
　  判断是否是空命令或退出命令－－＞
　  判断是否是改变工作路径命令(这个必须放到主进程里，详见后文课程小结)－－＞
    判断是否后台执行（是否以＆结尾）来建立不同类型子进程－－＞
    子进程执行命令函数execute()－－＞
    execute()里执行proexecute()函数，即先执行自定义模块init_command里的功能，若能执行到，则直接调用os._exit()方法退出则进程，进行下一次循环－－＞
    若不能，则执行系统调用函数的execvp()，将命令用shelx.split()方法分割成参数传入，execvp函数性质是执行是直接替换掉当前进程的内存，即执行后直接杀死当前子进程，故直接进行下一次循环－－＞
　　若自定义函数和系统调用执行命令都失败，则提示＇Invalid Command＇并退出子进程进行下一个命令接收－－＞
　　如此循环－－＞
  
This is my 'gethelp' document:
   HELP='Help on my handmake Python Shell[Pyshell]:\n' \
     '\n' \
     '---------------------------------------漂亮的分割线-----------------------------------------\n' \
     '\n' \
     '提示符格式：［Pyshell]+系统名＠用户名+用户权限：Working at 工作路径+pid（主进程ID）\n' \
     '\n' \
     '---------------------------------------漂亮的分割线-----------------------------------------\n' \
     '\n' \
     'Method Usage:\n' \
     '\n' \
     '--------------前端控制（这些必须在主进程（主函数）里执行，包括后面实现sub功能所用的管道）---------------\n' \
     '\n' \
     '      "Your cmd"& : \n' \
     '          后台运行这条指令，可以继续运行其他指令\n' \
     '      chdir path: (change directory)\n' \
     '          更改当前工作路径到path(path要合法，否则会提示不合法路径并忽略此条指令)\n' \
     '\n' \
     '--------------文件，目录控制(后面重定向有文件更多操作)-----------------------------------------－-\n' \
     '\n' \
     '      listdir:  (list derectory)\n' \
     '          以列表形式输出当前目录下所有文件（类似于linuxshell下的ls,输出形式是列表）\n' \
     '      makedir path: (make directory) \n' \
     '          当前工作目录下创建目录path\n' \
     '      makedirs path: (make multilevel directory )　\n' \
     '          于makedir类似，但可以创建多级目录\n' \
     '      rmdir path: (remove path)\n' \
     '          删除path这个目录（只能是目录）\n' \
     '      rmfile file: (remove file)\n' \
     '          删除file这个文件（只能是文件）\n' \
     '      getatime path/file:(get access time)\n' \
     '          输出文件（目录）的最后存取时间\n' \
     '      getctime path/file:(get create time)\n' \
     '          输出文件（目录）的创建时间\n' \
     '      getmtime path/file:(get modify time)\n' \
     '          输出文件（目录）的最后修改时间\n' \
     '      getsize path/file:(get size)\n' \
     '          输出文件（目录）的大小\n' \
     '\n' \
     '-------------命令替换操作------------------------------------------------------------------\n' \
     '\n' \
     '      sub cmdA as cmdB:\n' \
     '          临时的命令替换，A是你自定义命令，B为你要替换的命令（原命令不会失效），仅在本次运行中有效\n' \
     '      psub cmdA as cmdB: (permanent substitude)\n' \
     '          永久性的命令替换（退出本次程序后重新打开自定义依然有效）\n' \
     '          替换原则：临时＞永久：（临时和永久替换用了相同的关键字，则执行临时替换所对应的系统命令）\n' \
     '                  命令覆盖　：对同样的关键字进行多次替换，执行是会执行最后一次替换所对应指令\n' \
     '                  不验证所对应命令的有效性，但运行是会提示你自定义命令是无效的\n' \
     '\n' \
     '-------------重定向控制--------------------------------------------------------------------\n' \
     '\n' \
     '      redir cmd to file:(redirect the result of your command to file)\n' \
     '          将cmd指令的执行结果写入文件，而不是控制台（屏幕），会替换掉原文件内容\n' \
     '      redir cmd to file -a: (-a表示以追加的方式)\n' \
     '          执行结果追加到文件后面写入，而不影响文件原有内容\n' \
     '      redir from file:\n' \
     '          读取file里内容输出到控制台（屏显）\n' \
     '      redir from file -c: (-c表示当做命令来执行)\n' \
     '          读取file内容并将其当做系统命令执行（不可执行会提示命令无效）\n' \
     '      writeto file:\n' \
     '          提供一个文本输入流(以double＼n结束输入)，输出的内容会写到指定文件中（非追加\n' \
     '      writeto file -a: (-a表示追加的方式)\n' \
     '          写入结果追加到文件后面，而不影响文件原有内容\n' \
     '      文件存在性说明：redirto,writeto系列在文件不存在是会创建文件\n' \
     '                  redirfrom系列要求文件必须存在，不存在会提示＇文件不存在＇并忽略此条指令\n' \
     '\n' \
     '-------------管道控制----------------------------------------------------------------------\n' \
     '\n' \
     '      cmdA pipeto cmdB:\n' \
     '          cmdA的输出流（执行结果）直接当做cmdB的输入\n' \
     '          说明：这边实现的其实是一个伪管道，因为没有真正的缓冲机制，而且有些cmdB类的命令可能不能实现，\n' \
     '              　因为cmdB类命令必须是能本身够读取文件执行的命令格式\n' \
     '\n' \
     '------------------------------------------------------------------------------------------\n' \
     'Copyrigth@j142 10141346 linfeng\n' \
     '------------------------------------------------------------------------------------------'

DESCRIPTION='Author : 林锋  10141346   计142\n' \
            'Email : wobuxinnihuikan@163.com\n' \
            'Last Modify Time : 2017-6-20\n' \
            'Use "gethelp" to get help and"getout" to exit\n' \
            '----------------------------------------------------------------------------------------------'
            
几个核心功能思路（给你个眼神自己体会）：
    １．chdir（目录切换）功能实现必须放在主进程里，是必须，因为如果在子进程里实现，切换的只是子进程的工作路径，而子进程执行完他的工作后，就kill掉自己，相当与什么都没做．
    ２．sub功能实现临时的命令替换，这里要调用管道来传递自己的参数，把替换的命令传出来再添加到设置的临时索引表中，下次遇到此命令是再在次索引表中搜索．（也可以利用临时文件来实现，这也是一种思路）
    ３. 　psub功能是在内存建立一个存放替换命令的文件，替换命令存到文件中，每次执行先访问文件，通过一定关系建立一张索引表．
    ４ . 主程序里设置sub 和 psub执行顺序很重要，我这边规则是：
替换原则：临时＞永久：（临时和永久替换用了相同的关键字，则执行临时替换所对应的系统命令）\n' \
命令覆盖　：对同样的关键字进行多次替换，执行是会执行最后一次替换所对应指令\n' \
不验证所对应命令的有效性，但运行是会提示你自定义命令是无效的\n' \
    ５．输入输出重定向用到重写的sys.stdout输出流类的对象实现，实际是利用os.popen方法（实质是建立一个新子进程并利用管道接受执行结果）系统调用截取发回来的输出，但不是真正的从linux系统调用的底端IO流控制，因为sys.stdout这个函数定义就是这样的，不能干涉子进程的输入输出流．
    ６．管道的实现与重定向类似，其实是一个伪管道（在子进程里建立子进程），也没有真的的缓存机制和输入输出端控制．（这个可以调用真的管道os.fork实现，并设置缓存和输入输出机制，但是意味着要在主程序里建立两个子进程，会大改程序结构，可能破坏了程序可读性，所以我就没去搞嘿嘿也是有点懒）
    
补充说明．
    此程序具有比较高可读性，也提供不错的可扩展性和可维护性，添加功能可以直接在init_command里添加函数，再re_compile里添加一条正则表达式用于匹配命令，在主程序添加一条判断语句即可．本人小白，欢迎大家fork and pull requests  !         
           
